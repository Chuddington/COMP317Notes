# Note: 'C-c C-e d' compiles this to a LaTeX document automagically in org mode
# Note: 'C-c C-x C-l' provides in-line representation of LaTeX equations in
#        org mode, provided you have imagemagick or other image generators

* Lecture 10 - Game, Set and Maude

Maude can help express semantics by specifying 'sorts' (Syntactic Categories)
and Operations, which would be things like the phrase 'plus' to define that
something happens between two Numerals.  In a basic form:

op 0 : -> Num [ctor] .
op Inc : Num -> Num [ctor] .
op plus : Num Num -> Num .

The formatting shows the inputs and outputs for each operation.  The first, '0'
(zero), takes no input and has the output of a 'Num' (Base-10 Number, in this
instance), making it a constant instead of a variable.  The '[ctor]' defines
the operation as a 'constructor' as the statement generates data and therefore
constructs it.

The second statement is the format that will be used for an 'Increment'
capability.  We can see that there is a Num as an input, and the operation
creates a Num for an output.  This is also a constructor as it would
theoretically be able to generate all Numbers recursively.  If you have notes
made from the lectures, Inc(X) would be the same as 'Succ(X).'  I just prefer
the word 'Increment' as it is similar to other programming languages.

The third statement is the basic information for implementing addition in
Maude, accepting two inputs that are a part of the Num category and providing
a Num as an output.

The term '[ctor]' stands for 'Constructor' in Maude.  This flags the operation
as required for the sort as it forms the basis of other operations.
Essentially, most constants will be a constructor because they are used to
build sub-terms.  'Inc' is also a constructor as it will be used to build the
list of numbers by nesting Inc statements, like so:

Inc(Inc(Inc(0) ) ) == '3'

** Inductive definitions and Terms
Within the information above, we have a couple of terms.  Here is what we can
work out so far:

'0' is a term as it is a constant.
If 'T' is a term within sort 'Num,' then Inc(T) would be a term too.
If 'T1' and 'T2' are terms, then plus(T1, T2) is a term too.

We can see that because Inc(T) and plus(T1, T2) are built from other terms,
they are known as 'sub-terms.'

** Maude is stacked
sorts Bool Stack .
ops true false : -> Bool [ctor] .
op empty : -> Stack [ctor] .
op not   : Bool -> Bool .
# 'not' can be applied recursively:  not(not(true) ) == true
op push  : Bool Stack -> Stack [ctor] .
# Examples include: 'push(true, empty)' and 'push(false, push(true, empty) )'
op pop   : Stack -> Stack .
# 'pop(push(false, empty) )'
eq pop(push(B, S) ) = S .

The above code probably isn't correct, but you can at least see how a Stack may
be implemented in Maude.  There is a constant to define a stack, known as
'empty,' there is a 'not' operation to flip the value of a Boolean and the two
functions 'pop' and 'push' which remove an element from the stack or add an
element, respectively.  There is an equation to make make computation faster
for the case of pop(push(B, S) ).

As a very basic outline, Maude allows us to give names for concepts (such as an
empty stack) as well as operations (pop() and push() ).

** Maude vs. John Hancock
Within Maude, we are able to write a list of 'Sorts' (such as Stack, or Num) as
as well a list of Operations(Inc() and plus(), for example).  This gives us
something known as a 'Maude Signature.'  Written a little more formally, a
Maude Specification (Signature) gives:

(S, O) where:
S = A set of Sort Names, and
# {Num}; {Bool, Stack}
O = A set of Operation Names, and their input/output types

We can split the various types found within a Maude Specification into
'families' which are essentially all things which have the same input/output
types.  This is formalised with the form 'O    for w ∈ S, s ∈ S'
                                           w,s

So if we are to analyse the 'Num' sort, we would have this:

# All operations with nothing as an input and a Num as an output
O         = {0}
 [ ], Num

# All operations with a Num as an input and a Num as an output
# Note that 'inc' and 'succ' will do the same thing, but that is not required
# for them to be in a family together
O         = {Inc, Succ}
 Num, Num

# All operations with two Num's as an input and a Num as an output
# We have not specifically defined 'mult' and 'divi' but you can fairly easily
# guess how to using the semantics of 'plus' as a template
O             = {plus, mult, divi}
 Num Num, Num

# For any other amount of inputs, with a Num as an output, make it an empty set
O       = { }
 w, Num


We can do the same thing for the Stack sort too - it's constants will help
explain that even though values can be part of the same family, they do not
have to equal the same thing (true and false, for instance):

O           = {True, False}
 [ ], Bool

O           = {Empty}
 [ ], Stack

O           = {Not}
 Bool, Bool

O                  = {push}
 Bool Stack, Stack

O             = {pop}
 Stack, Stack

# All other inputs and outputs
O     = { }
 w, s


** Formalising Signatures
Within this module, the icon which will tell us that we are talking about a
signature will be 'sigma' (Σ).  Therefore, if we use our current knowledge from
before, Σ = (S, O).  In order to properly define a signature, we need to fill
in all of the available terms into the format that is seen above, which follows
'o ∈ O    '  (o exists within O    )
       w,s                      w,s

We define the terms of sort S ( (T )s ) for a couple of cases:
                                  Σ

'o ∈ O      ' (Constants within the sort)
       [ ],s

'o ∈ (T  )s   (True ∈ (T  )bool)
                         Σ
